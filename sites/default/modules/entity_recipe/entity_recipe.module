<?php 

/**
 * @file
 *
 * Module file for the Entity recipe module.
 */

/**
 * Implements hook_entity_info().
 */
function entity_recipe_entity_info() {
  $info = array();

  // Main ingredient entity.
  $info['ingredient'] = array(
    'label' => t('Ingredient'),
    'plural label' => t('Ingredients'),
    'description' => t('Ingredients to be used in recipes.'),
    'entity class' => 'Entity',
    'controller class' => 'EntityAPIController',
    'base table' => 'ingredient',
    'fieldable' => TRUE,
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
        'custom settings' => FALSE,
      ),
    ),
    'entity keys' => array(
      'id' => 'iid',
      'label' => 'name',
      'bundle' => 'type',
    ),
    'bundles' => array(
      'standard' => array(
        'label' => t('Standard'),
      ),
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'entity_recipe',
  );

  // Add bundle infor, but bypass entity_load() as we cannot use it here.
  $types = db_select('ingredient_type', 'it')
    ->fields('it')
    ->condition('type', 'standard', '!=')
    ->execute()
    ->fetchAllAssoc('type');
  foreach ($types as $type => $type_info) {
    $info['ingredient']['bundles'][$type] = array(
      'label' => $type_info->label,
      'admin' => array(
        'path' => 'admin/structure/ingredients/manage/&ingredient_type',
        'real path' => 'admin/structure/ingredients/manage/' . $type,
        'bundle argument' => 4,
        'access arguments' => array('administer ingredients'),
      ),
    );
  }

  // Seperate single-bundle entity to describe an ingredient in use in a recipe.
  $info['recipe_ingredient'] = array(
    'label' => t('Recipe Ingredient'),
    'description' => t('Ingredient used in a recipe.'),
    'entity class' => 'Entity',
    'controller class' => 'EntityAPIController',
    'base table' => 'recipe_ingredient',
    'fieldable' => TRUE,    
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
        'custom settings' => FALSE,
      ),
    ),    
    'entity keys' => array(
      'id' => 'riid',
    ),
    'label callback' => 'entity_recipe_ri_label',
    'module' => 'entity_recipe',    
  );

  return $info;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function entity_recipe_entity_property_info_alter(&$info) {
  $properties = &$info['ingredient']['properties'];

  $properties['name'] += array(
    'setter callback' => 'entity_property_verbatim_set',
  );

  $properties = &$info['recipe_ingredient']['properties'];

  foreach (array_keys($properties) as $key) {
    if ($key == 'riid') {
      continue;
    }
    $properties[$key] += array(
      'setter callback' => 'entity_property_verbatim_set',
    );
  }

  // Set the type to ingredient to enable chaining
  $properties['iid']['type'] = 'ingredient';
}

/**
 * Returns the label for the given entity.
 *
 * @param $entity
 *   Entity.
 * @param $entity_type
 *   Entity type.
 * @return string
 *   Label of the given entity.
 */
function entity_recipe_ri_label($entity, $entity_type) {
  // This always receives recipe_ingredient types so no need to check
  // NOTE: This is called from within a wrapper so it's safer to implement
  // it without using wrappers.
  $ingredient = entity_load_single('ingredient', $entity->iid);
  return $ingredient->label() . ' ' . $entity->qty . ' ' . $entity->qty_unit;
}