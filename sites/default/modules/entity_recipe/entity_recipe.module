<?php 

/**
 * @file
 *
 * Module file for the Entity recipe module.
 */

/**
 * Implements hook_entity_info().
 */
function entity_recipe_entity_info() {
  $info = array();

  // Main ingredient entity.
  $info['ingredient'] = array(
    'label' => t('Ingredient'),
    'plural label' => t('Ingredients'),
    'description' => t('Ingredients to be used in recipes.'),
    'entity class' => 'Entity',
    'controller class' => 'EntityAPIController',
    'base table' => 'ingredient',
    'fieldable' => TRUE,
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
        'custom settings' => FALSE,
      ),
    ),
    'entity keys' => array(
      'id' => 'iid',
      'label' => 'name',
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'entity_recipe',
  );

  // Add bundle infor, but bypass entity_load() as we cannot use it here.
  $types = db_select('ingredient_type', 'it')
    ->fields('it')
    ->execute()
    ->fetchAllAssoc('type');
  foreach ($types as $type => $type_info) {
    $info['ingredient']['bundles'][$type] = array(
      'label' => $type_info->label,
      'admin' => array(
        'path' => 'admin/structure/ingredients/manage/&ingredient_type',
        'real path' => 'admin/structure/ingredients/manage/' . $type,
        'bundle argument' => 4,
        'access arguments' => array('administer ingredients'),
      ),
    );
  }

  // A 'bundle definition entity' that stores information about each defined 
  // ingredient type.
  $info['ingredient_type'] = array(
    'label' => t('Ingredient type'),
    'plural label' => t('Ingredient types'),
    'description' => t('Ingredient types for the ingredient entity.'),
    'entity class' => 'IngredientType',
    'controller class' => 'EntityAPIControllerExportable',
    'base table' => 'ingredient_type',
    'fieldable' => FALSE,
    'bundle of' => 'ingredient',
    'entity keys' => array(
      'id' => 'id',
      'name' => 'type', // This field provides the machine-readable type name.
      'label' => 'label',
    ),
    'access callback' => 'entity_recipe_access',
    'module' => 'entity_recipe',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/structure/ingredients',
      'file' => 'entity_recipe.admin.inc',
      'controller' => 'IngredientTypeUIController',
    ),
  );

  // Seperate single-bundle entity to describe an ingredient in use in a recipe.
  $info['recipe_ingredient'] = array(
    'label' => t('Recipe Ingredient'),
    'plural label' => t('Recipe ingredients'),
    'description' => t('Ingredient used in a recipe.'),
    'entity class' => 'Entity',
    'controller class' => 'EntityAPIController',
    'base table' => 'recipe_ingredient',
    'fieldable' => TRUE,    
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
        'custom settings' => FALSE,
      ),
    ),    
    'entity keys' => array(
      'id' => 'riid',
    ),
    'label callback' => 'entity_recipe_ri_label',
    'module' => 'entity_recipe',    
  );

  return $info;
}

/**
 * Access callback for the entity API.
 */
function entity_recipe_access($op, $type = NULL, $account = NULL) {
  return user_access('administer ingredients', $account);
}

/**
 * Using a custom class for the ingredient type, enables us to define custom 
 * behavior for objects of the ingredient type entity. 
 * 
 * In this case we are adding a new method, called isLocked(), which tells
 * whether the type can be safely deleted or not.
 *
 * We're also overriding and extending the save() method, so that we can flush
 * the Field API's field info cache, so that changes to extra fields, added to
 * the entity, will be reflected.
 */
class IngredientType extends Entity {
  // Machine-name
  public $type;
  // Human-readable name
  public $label;
  // Listing weight
  public $weight = 0;

  public function __construct($values = array()) {
    parent::__construct($values, 'ingredient_type');
  }

  /**
   * Returns whether the ingredient types is locked (used in code or fixed).
   */
  public function isLocked() {
    return isset($this->status) && empty($this->is_new) &&
      ($this->status == ENTITY_IN_CODE || $this->status == ENTITY_FIXED);
  }

  /**
   * Overrides Entity::save().
   */
  public function save() {
    parent::save();
    field_info_cache_clear();
  }
}

/**
 * Ingredient type entity UI-controller.
 *
 * An example of how alterations to the Entity API's admin UI is done, by 
 * implementing a custom UI-controller. 
 * 
 * This is not required. The default UI-controller can be specified as 
 * 'controller class' in entity info, if there's no alterations required.
 */
class IngredientTypeUIController extends EntityDefaultUIController {
  /**
   * Overrides hook_menu() defaults.
   */
  public function hook_menu() {
    $items = parent::hook_menu();
    $items[$this->path]['description'] 
      = 'Manage ingredients, including fields.';
    return $items;
  }
}

/**
 * Implements hook_entity_property_info_alter().
 */
function entity_recipe_entity_property_info_alter(&$info) {
  $properties = &$info['ingredient']['properties'];

  $properties['name'] += array(
    'setter callback' => 'entity_property_verbatim_set',
  );

  $properties = &$info['recipe_ingredient']['properties'];

  foreach (array_keys($properties) as $key) {
    if ($key == 'riid') {
      continue;
    }
    $properties[$key] += array(
      'setter callback' => 'entity_property_verbatim_set',
    );
  }

  // Set the type to ingredient to enable chaining
  $properties['iid']['type'] = 'ingredient';
}

/**
 * Returns the label for the given entity.
 *
 * @param $entity
 *   Entity.
 * @param $entity_type
 *   Entity type.
 * @return string
 *   Label of the given entity.
 */
function entity_recipe_ri_label($entity, $entity_type) {
  // This always receives recipe_ingredient types so no need to check
  // NOTE: This is called from within a wrapper so it's safer to implement
  // it without using wrappers.
  $ingredient = entity_load_single('ingredient', $entity->iid);
  return $ingredient->label() . ' ' . $entity->qty . ' ' . $entity->qty_unit;
}